# Notes for the Semester
1. Well-Rounded Software Engineers
    - Capabale
    - Creative
    - Collaborative
    - Curious
2. History of Web-Programming
    - Internet--> originally for DOD
    - HTML (HyperText Markup Language)
    - HTTP (HyperText Transfer Protocol)
    - URL (Uniform Resource Locator)
    - CSS (Cascading Style Sheets)
    - JavaScript
    - Node.js (deploy JavaScript outside of browser-->JSON common object notation)
3. The Console
    - if POSIX compliant printf 'hello\n' will print hello
    - pwd (present working directory)
    - ls (list files), -la (in long format)
    - echo (output parameters of the command)
    - cd (change directory)
    - mkdir (make directory)
    - rmdir (remove directory)
    - rm (remove file)
    - mv (move file)
    - cp (copy file)
    - curl (Command line client URL browser)
    - grep (Regular expression search)
    - find (find files)
    - top (View running processes with CPU and memory usage)
    - df (view disk statistics)
    - cat (output the contents of a file)
    - less (interactively output contents of file)
    - wc (word count in file)
    - ps (view currently running process)
    - kill (kill a currently running process)
    - sudo (execute command as admin or super user)
    - ssh (create a secure shell on remote computer)
    - scp (securely copy files to remote computer)
    - history (show history of commands)
    - ping (check if website is up)
    - tracert (trace connections to a website)
    - dig (show DNS info for domain)
    - wget (downloads files from internet)
    - vim (VI oldest console editor)
    - nano (command line editor)
    - chmod +x deploy.sh (makes a script executable) (changes a file's mode bits to control the access rights to a file)
    - man (look up a command in the manual)
    - | (take output from left side and pass it to command on right)
    - '>' (output to file, overwrite if exists)
    - '>>' (output to file, append if exists)
    - CTRL-R (find previous commands)
    - CTRL-C (kill currently running command)
    - port 443 (HTTPS)
    - port 80 (HTTP)
    - port 22 (secure shell communication)
    - DNS (domain name system) associate with IP address (A record) other domains (CNAME records)
4. Git Hub commands
    - git add 
    - git commit
    - git push
    - git fetch
    - git status
    - git pull
    - git diff HEAD ~HEAD
    - git checkout (switch versions)
5. VI commands
   - :h (help)
   - i (insert mode, use ESC to exit)
   - u (undo)
   - CTRL-r (redo)
   - gg (go to beginning of file)
   - G (go to end of file)
   - / (search for text typed after /)
   - n (next search match)
   - N (previous search match)
   - v (visually select text)
   - y (yank or copy selected text to clipboard)
   - p (paste clipboard)
   - CTRL-wv (split window vertically)
   - CTRL-ww (Toggle windows)
   - CTRL-wq (close current window)
   - :e (open a file)
   - :w (write file (save))
   - :q (quit (:q! to exit without saving))

[Markdown Reference](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)

6. SSH into server
    - ssh -i[key pair file] ubuntu@[ip address]
7. Caddy
    - webserve that listens for incoming HTTP requests
    - routes requests--> gateway or reverse proxy
8. HTTPS/TLS
    - HTTPS (Secure HyperText Transport Protocol)
    - TLS (negotiates shared secret and used to encrypt data)
    - uses handshakes that verify web certificate
    - Web certificates are generated by trusted 3rd party using public/private key encryption (cheaper because of Let's Encrypt-->creates them for free)
9. HTML
    - elements are enclosed in tags
    - html element--> represents top level page structure
    - head element -->metadata about page and page title
    - body element --> content structure
    - main element --> main content structure
    - attributes give specific detatils of an element
    - id, class helps group things
    - hyperlinks (<a href="__">Title</a>
    - Always inclue <!DOCTYPE html> at the top of document
    - nav (navigational inputs)
    - section (section of main content)
    - aside (aside content of main content)
    - div (block division)
    - span (inline span of content)
    - b (bring attention)
    - img (image reference)
    - dialog (interactive component such as confirmation)
    - Comments (<!-- _____ -->)
    - body has children (header, main, footer)
    - block (div, p)
    - inline (b, span)
    - form (input container and submission)
    - fieldset (labeled input grouping)
    - input (multiple types of user input: text, date, checkbox, color, etc w/ attributes (name, disabled, value, required) w/ validation (certain patterns)
    - select (selection dropdown)
    - optgroup (grouped selection dropdown)
    - option (selection option)
    - textarea (multiline text input)
    - label (individual input label)
    - output (output of input)
    - meter (display value with a known range)
    - index.html default display for web browser
    - external media (img, audio, video)
    - For images, it is best to have them saved in a repository and use the reference links so it does not take as long to load
    - Always include an alt for images (for accessibility)
    - images (<img src="_" alt="_")
    - audio (src, controls or it autoplays and loops)
    - video (src, controls or autoplay, crossorgin="anonymous" (when requssting files from different domain)
    - internal media (svg, canvas)
    - Scalable Vector Graphics (SVG)
    - Canvas (2D drawing/animation)
    - Structure is like a tree
    - Be sure to close out all tags
    - Spans hightlight specific text or sections
10. Simon HTML
    - need a deploy file to be able to send to website
    - include navigation on every page
    - Use Live Server to view so you can debug
11. CSS
    - Cascading Style Sheets (style html)
    - responseive to actions of user and device rendered on
    - animate page, deploy custom fonts, respond to user actions, dynamically alter entire layout based on size of device
    - rulesets --> selector, declarations, property, value
    - Example (p (selector){color (property): (declaration) green (value); (rule)}
    - Ways to associate CSS with HTML
          1. Style attribute in specific HTML element
          2. Style element (<style>) within HTML document
          3. HTML link to create hyperlink ref to external file with CSS rules (<link rel="stylesheet" href="styles.css" />) ** preferred way
    - Lowest level overrides higher declaration
    - Box model (inner to outer--> content, padding, border, margin)
    - Selectors (* to select all)
    - descendant combinator (ex. section h2)--> has to be a descendent of previous item
    - child-->list of direct children (ex. section > p)
    - general sibling --> list of siblings (ex. div ~ p)
    - adjacent sibling --> list of adjacent sibling (ex. div + p)
    - Class selector (.classname {})
    - Can combine with element name (ex. p.classname{})
    - ID selector (unique for a specific element) (ex. #id {})
    - Attribute selector (ex. p[class='summary'] {} or a[href] {})
    - Pseudo selector--> selects basked on position, hyperlick visit, or mouse interactions (ex. section:hover {})
    - CSS Declarations (property=value)
    - Units for values (pixels (px) or inches (in) or % of parent element or % of minimum viewport dimension (vmin) or multiplier of size of letter m in root font (rem), pt(number of points 1/72 in), cm (centimenters), em (multiplier of width of letter m in parent font), ex (height of element font), vw, vh (viewport width or height), vmax (%of viewportlarger dimension)
    - Color: keyword (red), RGB (#00FFAA22 or #0FA2), rgb function (rgb(128,255,128,0.5) with opacity as last thing), HSL (hsl(180,30%,90%,0.5) hue,saturation (how gray), light (how bright))
    - font-family to import fonts, list several in order of desire b/c some systems don't have some types
    - font families--> serif, sans-serif, fixed, symbol (emojis or arrows)
    - @font-face {} to load one you provide
    - load from font provider (@import url()) using Good Font Service
    - Animation--> use animation properties, define keyframes (how it looks at different times)
    - in element reference animation (animation-name and animation-duration)
    - @keyframes nameofanimation { from {} to{} }
    - can add % of the way through stops in between from and to 
12. Responsive Design
    - change how HTML element displayed
    - none (don't display)
    - block (width of parent element)
    - inline (width as big as contents)
    - flex (flexible orientation)
    - grid (grid orientation)
    - include meta tag in head element so mobile browser scaling does not get in the way (<meta name="viewport" content="width=device-width,initial-scale=1" />
    - float (moves element to left or right and allows inline elements to wray around) (ex. aside {float:right; } stays of right side while text flows around)
    - Media queries (@media) dynamically detects size and orientation, can use it too see which side is longest on device so we know how to orient) or to know when to not display some items
    - Grid (display:grid; ) (fr-->gractional unit of parentss total width)
    - Flexbox (partition application into areas that move around as window resized or orientation changes) (display: flex; flex-direction:column or row; flex:1(one-fractional unit)) (row-->side by side, column-->on top of each other)
    - Frameworks (tailwind-->newer, apply to specific HTML elements--> mostly in HTML file) (bootstrap--> (include in head <link href="", rel="stylesheet", integrity="", crossorigin-"anonymous" />) (include at end of body element (incorporate javascript module) <script src="" integrity="" crossorigin="anonymous"></script>)
    - Debugging (inspect, Elements tab, Styles pane)-->can change things directly in debugger
    - flex to delimit header, main, and footer (responsive to different screen sizes)
    - absolute position relative to parent elements
14. JavaScript
    - officially ECMAScript--> weakly typed language
    - most used programming language (web servers and serverless functions)
    - executed using an interpreter instead of compiling (very portable but allows for errors (only discovered when crashes during execution))
    - console.log(___) outputs ot debugger console
    - concatenate using +
    - write functions (function name(variable){return variable+' ';}
    - line comment //
    - block comment /* */
    - end statements with ;, code blocks/scope defined w/ {}
    - console.time('demo time'); code; console.timeEnd('demo time');
    - console.count(_);
    - Adding to HTML
          - src attribute of script element (reference js file)
          - directly in HTML in script element (ex. write function here)
    - onclick-->creates event listener for DOM events that call code in attribute value
    - declare variables with let or const, never var
    - primitive types: null (not assigned value), undefined (has not been defined), Boolean, number, bigInt (arbitrary magnitude), String, Symbol (unique value)
    - object types: object (collection of properties represented by name-value pairs (ex. {a:3, b:'fish'}), function, date, array, map, JSON (lightweight data-interchange format (ex. {"a":3,"b":"fish"})
    - operators: + (add), - (subtract), * (multiply), / (divide), === (equality), for strings (+ and ===)
    - type conversions: weakly typed-->type changes when assigned new value or automatically converted in certain contexts (automatic converstion) (== less intuitive use === for strict inequality)
    - examples (2 + '3';
        // OUTPUT: '23'
        2 * '3';
        // OUTPUT: 6
        [2] + [3];
        // OUTPUT: '23'
        true + null;
        // OUTPUT: 1
        true + undefined;
        // OUTPUT: NaN)
    - examples (1 == '1';
        // OUTPUT: true
        null == undefined;
        // OUTPUT: true
        '' == false;
        // OUTPUT: true)
      -examples (1 === '1';
        // OUTPUT: false
        null === undefined;
        // OUTPUT: false
        '' === false;
        // OUTPUT: false)
    - Conditionals (if, else, else if)
    - ternary operator (ex. a===1? console.log(1) : console.log('not 1');)
    - boolean operations (&&(and) || (or) ! (not))
    - loops (for, for in, for of, while, do while, switch)
    - for in (const name in obj-->prints out first part of each object, const name in array-->prints out the array index)
    - for of (const val of arr-->print value at each index)
    - break or continue also available
    - string-->specified by ',", or ` (` are string literal that could have JavaScript evaluated in place and concatenated into string)
    - string literal replacement specifier ${} use backticks
    - use backticks to create multiline strings w/o having to use \n
    - Unicode-->must internationalize (uses sequence of 16-bit unsigned integers)
    - String functions (length, indexOf()-starting index of given substring, split()-split into array on given delimiter, startsWith()-returns boolean, endsWith()-returns boolean, toLowerCase()
15. JavaScript Functions
    - first class object-->assigned name, passed as parameter, return result, referenced
    - if don't give value of parameter, undefined when function executes
    - can define default value
    - anonymous functions-->assign to variable w/o giving it a name
    - inner functions--> declare inside other functions, modularize code w/o exposing private details
16. JavaScript Arrow Function
    - first order objects
    - anonymous functions clutter--> more compact-->arrow syntax (use => instead of function keyword)
    - ex. ()=>3; (takes no parameters and always returns 3)
    - example of difference:
           // standard function syntax
            a.sort(function (v1, v2) {
              return v1 - v2;
            });
            // arrow function syntax
            a.sort((v1, v2) => v1 - v2);
    - arrow functions cannot be used for constructors or iterator generators
    - return keyword is optional if no curly braces and only has 1 expression-->automatically returned
    - if curly braces-->acts like standard function and needs return statement
    - inherits this pointer from scope (forms closure)
    - closure allows function to continue referencing creation scope even if it has passed out of scope (returns values from scope it was created not current values of the variables)
    - example (debounce (timewindow, window function to call in this timeframe)-->resets page so expensive calculations are not called too much
17. JavaScript Array
    - sequence of other objects and primitieves
    - zero based index
    - static functions (push (add to end), pop (remove from end), slice (subarray), sort, values (interator for use in for of loop), find (first item satisfied by test function), forEach (function on each item), reduce (reduce array to single item), map (function to map array to new array), filter (function to remove items), every (function to see if all match), some (function to see if any match)
18. JSON
    - JavaScript Object Notation
    - simple, effective way to share and store data, easily convertible to and from JavaScript objects
    - document contains one of the data types (string (""), number, boolean, array[,], object ({"a":1}), null
    - commonly contains object (0 or more key value pairs), key is always a string and object has to be a data type listed above
    - encoded with UTF-8
    - convert to and from JSON with JSON.parse and (JSON.stringify (to))
    - JSON cannot represent JavaScript undefined obj so gets dropped in conversion
19. JavaScript Object and Classes
    - property name must be String or Symbol, value any type
    - can be created with new operator (ex. const obj=new Object ({a:3});)
    - This allows adding properties by simply referencing property name (can be done with obj.prop or obj['prop'])
    - Great for dynamically modifying and manipulating data with indeterminate structure (promises are also objects)
    - Object-literals
    - example: const obj = {
                  a: 3,
                  b: 'fish',
                };
    - Object functions (entries (returns key value pairs), keys, values)
    - Constructor (function that returns an object)
    - can be invoked with "new" operator
    - this depends on scope (for an object, it is a pointer to the object)
    - Classes-->reusable conmponent, explicit consstructor and assumed function declarations
    - Example: class Person {
                  constructor(name) {
                    this.name = name;
                  }
                
                  log() {
                    console.log('My name is ' + this.name);
                  }
                }
    - make properties and functions private by prefixing with #
    - Inheritance: classes can be extended using extends keyword
    - super function-->pararmeters that need to be passed to parent class
    - super keyword--> explicitly access parent function
    - example: class Person {
                  constructor(name) {
                    this.name = name;
                  }
                class Employee extends Person {
                  constructor(name, position) {
                    super(name);
                    this.position = position;
                  }
20. JavaScript Regular expressions
    - textual pattern matcherss (find text in string so you can replace it or know it exists)
    - create using class constructor or regular expression literal
    - const objRegex = new RegExp('ab*', 'i');
    - const literalRegex = /ab*/i;
    - match, replace, search, split (accept regex)
    - flags: g (global search), i (case-insensitive search))
21. JavaScript Rest and Spread
    - rest syntax (...numbers)
    - call it with any number of parameters and automatically combined into array
    - only last parameter can be made rest parameter
    - allows variadic functions
    - Spread (opposite of rest)
    - takes iterable object and expands into function's parameters
22. JavaScript Exceptions
    - try catch and throw syntax
    - throw exception, try and catch block, and finally if want
    - example: try {
              // normal execution code
            } catch (err) {
              // exception handling code
            } finally {
              // always called code
            }
    - throwing exceptions should only happen when something truly exceptional occurs
    - Fallbacks (return something even if something is temperarily unavailable)
23. JavaScript Destructuring
    - pulling indivitual items out of existing one
    - done with arrays or objects
    - arrays it is assumed by position
    - for objects, explicitly specify
    - example: const o = { a: 1, b: 'animals', c: ['fish', 'cats'] };      
                    const { a, c } = o;
                    console.log(a, c);
                    // OUTPUT 1, ['fish', 'cats']
    - map names to new variables if wish
    - give default values as well for missing ones
    - can also reassign existing variables
24. Scope
    - Types of scope: global (visible to all code), module (visible to code running in module), function (visible within function), block (visible in block of code (inside {}))
    - var used to be used but it ignores block scope (just assign new value in each function instead of declaring new variable within each section)
    - this represents variable that points to object
    - automatically declared
    - reference this anywhere in JavaScript program
    - value depends on context in which referenced
        1. Global--> represents context for runtime environment (for browser-->browser window object)
        2. Function--> referenced in a function-->refers to object that owns function (either object or gloablThis if function defined outside object), when running JavaScript strict mode--> global function's this variable is undefined 
        3. Object--> referenced in object, refers to object
        4. Example: 'use strict';
                        // global scope
                        console.log('global:', this);
                        console.log('globalThis:', globalThis);
                        // function scope for a global function
                        function globalFunc() {
                          console.log('globalFunctionThis:', this);
                        }
                        globalFunc();
                        // object scope
                        class ScopeTest {
                          constructor() {
                            console.log('objectThis:', this);
                          }
                          // function scope for an object function
                          objectFunc() {
                            console.log('objectFunctionThis:', this);
                          }
                        }
                        new ScopeTest().objectFunc();
                        Running the above code in a browser results in the following.
                        global: Window
                        globalThis: Window
                        globalFunctionThis: undefined
                        objectThis: ScopeTest
                        objectFunctionThis: ScopeTest
                        Note that if we were not using JavaScript strict mode then globalFunctionThis would refer to Window.
    - Closure-->function and its surrounding state
    - whatever variables are accessible when function created are available inside the function
    - true even if pass function outside scope of original creation
    - function creates object with this pointer--> returns object
    - globalThis and then arrow function created with this pointer-->returns globalThis
    - globalThis and returned arrow function created with this pointer--> returns object
25. JavaScript Modules
    - allow for partitioning and sharing of code
    - Node.js introduced concept of modules (now available in JavaScript)
    - JS modules-->ES modules
    - create file-based scope--> must explicitly export objects and import into other file
    - modules can only be called from other modules
    - specify using ES module by including type attribute with value of module in script element
    - if want to use module in global scope-->leak to global scope--> attach event handler or explicitly add function to global window object
    - Example: <html>
                  <body>
                    <script type="module">
                      import { alertDisplay } from './alert.js';
                      window.btnClick = alertDisplay;
                
                      document.body.addEventListener('keypress', function (event) {
                        alertDisplay('Key pressed');
                      });
                    </script>
                    <button onclick="btnClick('button clicked')">Press me</button>
                  </body>
                </html>
    - Use web framework bundler to generate web application distribution code, don't have to worry about differentiationg between scope-->will inject necessary syntax to connect-->bundler exposes ES module directly
26. Document Object Model(DOM)
    - <!DOCTYPE html> (directs browser to use relevant specifications when rendering the html)
    - object representation of HTML elements used to render display
    - can write programs that dynamically manipulate the HTML
    - browser provides access to DOM through global variable name (document) that points to root element of the DOM
    - everything in HTML document has a node in the DOM
    - includes elements, attributes, text, comments, whitespace
    - form a big tree with document at the top
    - elements implement DOM element interface (comes from DOM Node Interface)
    - DOM Element Inerface-->iterate child elements, access parent elements, manipulate element attributes
    - querySelectorAll (select elements)
    - document.getElementById(id).style.color = __ (to change text color)
    - document.querySelector(__).textContent= "" (to rewrite info)
    - can use document.querySelector();
    - textContent (contains all the elements text)
    - innerHTML (textual representation of elementss HTML content)
    - Modifying the DOM
    - create a new element (document.createElement();)
    - insert new element by appending to existing element (parentElement.appendChild();)
    - delete elements (child.parentElement.removeChild(child);)
    - Injecting HTML
    - can inject blocks of HTML into element
    - common attack vector for hackers as users
    - make sure it cannot be manipulated by user
    - injection paths (HTML input controls, URL parameters, HTTP headers)
    - sanitize HTML that contains variables or use DOM manipulation functions instead of using innerHTML
    - Event Listeners
    - function that gets called when event occurs on element
    - add listener to: clipboard, focus, keyboard, mouse, text selection
    - example: const submitDataEl = document.querySelector('#submitData');
                submitDataEl.addEventListener('click', function (event) {
                  console.log(event.type);
                });
    - add event listeners directly  in HTML
    - example: <button onclick='alert("clicked")'>click me</button>
28. Local Storage
    - ability to persistently sotr and retrieve data on user's brower across user sessions and HTML page renderings
    - also cache when data cannot be obtained from the server
    - functions
    - setItem(name, value)
    - getItem(name)
    - removeItem(name)
    - clear()
    - local storage value must be string, number, or boolean
    - if want to store JavaScript object or array-->convert to JSON string with JSON.stringify() when inserted and convert back with JSON.parse()
29. Promises
    - rendering process of HTML executes on single thread
    - cannot take a long time to process JavaScript at beginning
    - use promise for long running executions
    - background execution
    - create promise by calling Promise object constructor and pass executor function that runs asynchronously (promise constructor may return before executor function runs)
    - states of promise execution (pending (currently running asynchronously), fulfilled (completed successfully), rejected (failed to complete))
    - promise executor takes two functions as parameters (resolve, reject)
    - resolve-->fulfilled state, reject-->rejected state
    - promise object has 3 functions: then,catch, finally
    - then-->called if fulfilled, catch-->called if reject, finally--> always called after processing completed
    - example: const coinToss = new Promise((resolve, reject) => {
                  setTimeout(() => {
                    if (Math.random() > 0.5) {
                      resolve('success');
                    } else {
                      reject('error');
                    }
                  }, 10000);
                });
      - if in promise, reject(false); catch and finally statements occur
30. JavaScript Async/await
    - await wraps execution of promise (removing chain functions), blocks the promise state moves to fulfilled or throws exception if moves to rejected
    - set up this way: const coinToss = () => {
                          return new Promise((resolve, reject) => {
                            setTimeout(() => {
                              if (Math.random() > 0.1) {
                                resolve(Math.random() > 0.5 ? 'heads' : 'tails');
                              } else {
                                reject('fell off table');
                              }
                            }, 1000);
                          });
                        };
    - different versions of setup:
    - then/catch chain version
            coinToss()
              .then((result) => console.log(`Toss result ${result}`))
              .catch((err) => console.error(`Error: ${err}`))
              .finally(() => console.log(`Toss completed`));
    - async, try/catch version 
            try {
              const result = await coinToss();
              console.log(`Toss result ${result}`);
            } catch (err) {
              console.error(`Error: ${err}`);
            } finally {
              console.log(`Toss completed`);
            }
    - async
    - cannot call await unless top level of JavaScript or in function definded with async
    - async transforms function so it returns a promise that will resolve to value previously returned by function
    - return value of async function--> Promise {<state>: value}
    - if async function set up to return new Promise --> Promise {<pending>}
    - await then returns result of promise
    - await function();-->will return value from function
    - great for feching web API that returns JSON (resolve two promises--> network call and converting result to JSON) need to wait until first resolved)
31. Debugging JavaScript
    - simplest way--> console.log
    - use debugger console window to inspect variables
    - execute JavaScript directly in console window
    - browser debugger--> select source tab, select index.js, breakpoints, refresh (reload and pause on breakpoint)
32. Node.js
    - application to deploy JavaScript outside browser
    - run on server as well
    - can power entire technology stack
    - execute a line of JavaScript with Node.js from console with -e parameter
          - node -e "console.log(1+1)"
    - really actually create file index.js that references code found in rest of project
          - node index.js
    - can run node in interpretive mode by executing without parameters (just type "node") and then typing JavaScript code directly into the interpreter
    - helpful to use packages--> install pacakges locally with NPM (Node Package Manager) and then include require statement in code that references the pacakge name
    - first initialize code to use NPM
          - create directory that will contian JavaScript
          - run npm init (return to accept defaults) or put -y at end
    - package.json was created-->1. metadat about project, commands that you can execute, packages the project depends on
    - npm install [name of package]
    - npm uninstall [name of package]
    - NPM creates package-lock.json and directory with node_modules (will get very large)
    - PUT node_modules in .gitignore file
    - When clone source code on new location --> run npm install
    - package-lock.json ensures that different versions are not downloaded, ensuring compatability
33. Debugging Node.js
    - Debug JavaScript in VS Code
    - Start Debugging (F5)-->use Node.js debugger
34. Web frameworks
    - Simplify common patterns, provide common componenets, improve performance, increase device coverage
    - tools to modularize code, create single page applications, simplify reactivity, support diverse hardware devices
    - Some frameworks make new file formats that combine languages into one file (ex. React)
    - focus on functional components rather than files
    - Types: Vue (HTML, CSS, JAvaScript in single file), Svelte (same as Vue but requires transpiler instead of DOM),REact (JAvaScript and HTML in component format with CSS outside the file, componenet leverages functionaligy of JavaScript, represented as function or class)
    - Angular component (defines what JavaScript, HTML, and CSS are combined together, strong separation of files)
    - virtual DOM (shadow DOM), takes copyonly in memory, really fast, changes happen in here first (make new tree), finds diff between and then only changes the diff in web browser tree, constantly watching components to see what changes
35. React (JSX)
    - Combines javascript and html (Babel talks between JSX to make JS)
    - Use in Codepen if select Babel as JavaScript processor
    - less html used within document
    - React.createElement (generates DOM elements and monitors the data for changes, when changes occur, React triggers dependet changes)
36. Components
    - React components allow modularization of functionality of page
    - enables code reuse
    - generage user interface-->done with "render"-->puts what is returned into HTML element
    - Allow you to pass information to themin form of element properties
          - receives properties in constructor and then displays once it renders
    - components can have internal state
          - Created with React.useState (hook function)
          - returns a variable that gives current state and function to update the state
    - function style components above
    - can have class style but right now moving away from these
    - porperties loaded into constructor and state set using setState function on component object
    - Reactivity controls how componetent reacts to actions or event
    - Component properties and state used to determine reactivity
    - When these change--> render function and dependent functions are called
37. React hooks
    - Hooks allow React function style components to do have capability and more of class style componenets
    - New features are included as hooks
    - hooks can declare and update states in a function component (use useState hook)
    - useEffect hook --> represent lifecycle events (could run function everytime componenet renders or return a cleanup function as well)--> great for creating side effects for things such as tracking
    - Hook dependencies
    - Control what triggers a useEffect hook by specifying dependencies
    - if specify an empty array [] as hook dependency--> only called when component is first rendered
    - hooks can only be used in function style componenets and must be called at top scope of function (cannot be inside loop or conditional)
    - This allows hooks to always be called in the same order when component rendered
38. Router
    - web framework router provides essential functionality for single-page applications
    - browser only loads one HTML and JavaScript manipulates the DOM to give it the appearance of multiple pages
    - router defines routes a user can take and automatically manipulates DOM to display appropriate framework components
    - use react-router-dom Version 6 (derives from react-router for core functionality)
    - implementation: BrowserRouter component that holds entire application and controls routing. Link (NavLink) component holds user naviagtion events and modifies what is rendered by the Routes component (matches the to and path attributes)
39. Reactivity
    - Reactivity enabled through props, state, and render
    - JSX rendered-->React parses it and creates a list of references to component's stat or prop object and then monitors them. If changes seen--> calls render function so the change can be seen
    - don't assume when state will be updated. Even if you use updateState does not mean it will be updated by next line of code as updates happen asychronously (we only know that it will eventually happen)
40. Toolchains
    - common functional pieces in a web application tool chain
    - Code repository--> store code in a shared, versioned location
    - Linter--> removes or warns of non-idiomatic code usage
    - Prettier-->Formats code according to shared standard
    - Transpiler--> compiles code into a different format (JSX to JavaScript)
    - Polyfill-->Generates backward compatible code for supporting old browser versions that do not support the latest standards
    - Bundler-->Packages code into bundles for delivery to the browser (enables compatibility (ex. EX6 module support) or performance (lazy loading))
    - Minifier-->Removes whitespace and renames variables in order to make code smaller and more efficient to deploy
    - Testing--> Automated tests at muliple levels to ensure correctness
    - Deployment--> Automated packaging and delivery of code from the development environment to the production environment
    - For us: GitHub (code repository), Vite ( JSX, TS, development and debugging support), ESBuild (converting to ES6 modules and transpiling (with Babel underneath)), Rollup (for bundling and tree shaking), PostCSS (for CSS transpiling), simple bash script (deployReact.sh for deployment)
41. Vite
    - Use CLI (Command LIne Interface) to initially set up web application
    - This saves trouble of configuring toolchain parameters and gets you started with default application
    - Vit bundles code quickly, has great debugging support, allows to easily support JSX, TypeScript, and different CSS flavors
    - Run this code: npm create vite@latest demoVite -- --template react
            cd demoVite
            npm install
            npm run dev
    - This creates a new web application in the demoVite directory, download required 3rd party packages, start up the application using a local HTTP debugging server
    - press o to open browser to the URL that is hosting application
    - press h to see all the Vite CLI options
    - press q to return to console and stope Vite from hosting the application
    - Files created by Vite
          - ./index.html-->primary application page, starting point to load all JSC components (beginning with main.jsx)
          - ./package.json --> NPM definition for package dependencies and script commands (maps "npm run dev" to actually start up Vite)
          - ./package-lock.json --> Version constraints for included packages (do not edit this)
          -./vite.config.js--> configuration setting for Vite (sets up React for development)
          - ./public/vite.svg--> vite logo
          - ./src/main.jsx --> entry point for code execution (loads App component found in App.jsx)
          - ./src/index.css --> css for the entire application
          - ./src/App.jsx --> JSX for top level application (displays the logs and implements click counter)
          - ./src/App.css --> CSS for the top level application component
          - ./src/assets/react.svg --> react logo for display in the app
    - main.jsx creates React application by associating #root element with App component in App.jsx--> causes render functions to execute-->generated HTML,CSS, and JavaScript executed in index.html
    - Vite CLI uses .jsx extension for JSX files instead of .js
    - Babel transpiler works with either but editor tools work differently based upon extension
    - When execute "npm run dev", bundling code to a temporary directory that the Vite debug HTTP server loads from
    - When bundling application so you can deploy to a production environment, run "npm run build" (executes build script found in package.json and invokes Vite CLI)
      - "vite build" transpiles, minifies, injects the proper JavaScript, then outputs everything to a deployment-ready version contained in the distribution subdirectory named dist
      - deployReact.sh creates production distribution by calling "npm run build" and then copying the dist directory that was created to the production server
42.  Internet
    - connects most of the computers in the world (connects networks and computing devices)
     - need IP address (users use domain names (which are converted to IP addresses by DNS (Domain Name System))
     - look up IP address using "dig" in the console
     - connect to device by asking for connection route (many hops across network)
     - "traceroute" in console to see what connection route was made (dynamically calculated so it could change)
     - ability to discover a route makes internet resilient when network devices fail or disappear from network
     - sending data involves TCP/IP model (physical wires to data sent)
          - application layer (user functionality-->web (HTTP), mail (SMTP), files (FTP), remote shell (SSH), chat (IRC))
          - transport layer--> breaks application layer info into small chunks and sends data (ex. TCP)
          - internet layer--> where real connection made--> finds device and keeps connection (ex. IP)
          - link layer--> physical connections and hardware (ex. Fiber)
43. Web Servers
    - computing device that host web service that know how to accept incoming internet connections and speaks HTTP application protocol
    - being able to easily create web services makes it easy to build web services right into web application
    - common to find multiple web services running on same computing device
        - these are run on different ports
        - use service gateway (reverse proxy) a web service that looks up requests and map them to other services running on other ports
        - we use Caddy
    - microservices (single functional purpose that web services provide)
    - partition functionality to small logical chunks so you can develop and manage them independently from other functionality into larger system
    - handle large fluctuations in user demand by running more copies of microservice from multiple virutal servers
    - basically just run more instances of service
    - serverless functionality--> just write function that speaks HTTP that is loaded through gateway (would automatically scale hardware needed based on demand)--> reduces what needs to be done
44. Domain names
    - use "dig" to get IP address for any domain
    - sometimes multiple IP addresses for same domain name--> redundancy in case an IP address fails to connect (b/c server not responding)
    - domain names-->follow naming convention--> found in Domain Name Registry, made up  of root domain with 1+ subdomain prefixes
    - root domain has secondary level and top level domain (TLD) (ex. com, edu, click)
    - TLD's are controlled by ICANN (a governing board of the internet)
    - create subdomains which might have different iP addresses
    - info about domain name using "whois" in console
    - once a domain name is in registry--> listed with a domain name system (DNS) server and associated with IP address
    - lease IP address
    - there are authoritative name servers
    - records that allow the mapping
        - address (A)--> straight mapping from domain name to IP address
        - canonical name (CNAME)-->map from one domain name to another one (alias)
    - Process: put domain name in browser, browser checks to see if already has the name in cache, if not contact DNS server and get IP address if in cache, if not gets from authoritative name server, if not there get error, if found in any step HTTP connection
    - lots of caching for performance reasons--> hard if trying to update info with domain name-->use (TTL) or time to live setting so then the different layers clear cache after requested period
45. Web services
    - when frontend (all HTML, CSS, JavaScript, and image files) requests from webserver--> uses HTTPS protocol
    - ALL web programming requests between devices use HTTPS to exchange data
    - from frontend JavaScript--> requests to external services anywhere
    - to make web service request (give URL of web service to fetch function)
    - Creat own web service --> will provide static frontend files, functions to handle fetch requests for storing data, providing security, running tasks, executing application logic in background, and communicating with other users
    - functionality-->backend
    - functions provided by webservice--> endpoints (APIs)
    - access web service endpoints from frontend JavaScript with fetch function
46. URL
    - Uniform Resource Locator (URL) represents location of web resource
    - web resources--> web page, font, image, video stream, database record, JSON object, or more ephemeral (visitation counter or gaming session)
    - many parts with punctuation-->only scheme and domain name are required
          -Scheme (ex. https)--> protocol required to ask for resource (usually HTTPS but could be FTP or MAILTO)
          - Domain name (ex. byu.edu)--> owns resource represented by URL
          - Port (ex. 3000)-->specifies numbered network port used to connect to domain server (lower number ports for common internet protocols, higher number ports used for any purpose) (port 80-->HTTP or port 443-->HTTPS)
          - Path (ex. /school/byu/user/8014)-->path to resource on domain, resource does not have to physically be located on file system with path, could just be a logical path representing endpoint parameters, database table, or object schema
          - Parameters (ex. filter=names&hightlight=intro,summary)-->represents a list of key value pairs (provides additional qualifies on resource represented by path), could be a filter on returned resource or how to highlight the resource, parameters sometimes called query string
          - Anchor (ex. summary)-->represents sub-location in resource, for HTML pages represents request for browser to automatically scrll to element with an ID that matches the anchor, Anchor sometimes called the hash or fragment ID
      - could proved user name and password before domain name (how access was authenticated before) but no longer used for security
      - Uniform Resource Name (URN)--> resource name that does not specify location info
      - Uniform Resource Identifier (URI)-->refers to either URL or URN
47. Port
    - To connect device to internet, need IP address and numbered port
    - Port numbers allow device to support multiple protocols (HTTP,HTTPS, FTP,SSH) and services (search, document, authentication)
    - Ports can be exposed externally or only used internally on device
    - IANA, internet govering body, defines standard usage for port numbers
    - Ports 0 to 1023 represent standard protocol
    - web services should aboid these ports unless porviding protocol represented by standard
    - Ports 1024 to 49151 represents ports assigned to requesting entities
    -     common for ports to be used by services running internally on a device
    - Ports 49152 to 65535 are considered dynamic and are used to create dynamic connections to device
    - Common Ports
    - 20-->File Transfer Protocol (FTP) for data transfer
    - 22-->Secure Shell (SSH) for connecting remote devices
    - 25-->Simple Mail Transfer Protocol (SMTP) for sending email
    - 53-->Domain Name System (DNS) for looking up IP addresses
    - 80-->Hypertext Transfer Protocol (HTTP) for web requests
    - 110-->Post Office Protocol (HTTP) for web requests
    - 123-->Network Time Protocol (NTP) for managing time
    - 161-->Simple Network Management Protocol (SNMP) for managing network devices such as routers or printers
    - 194-->Internet Relay Chat (IRC) for chatting
    - 443-->HTTP Secure (HTTPS) for secure web requests
    - For web server--> externally exposed port 22 so I could use SSH to open remote console on server, port 443 for secure HTTP communicationa dn port 80 for unsecure HTTP communication
    - Caddy is listening on ports 80 and 443 (automatically redirects from 80 to 443)
    - for 443, Caddy examines path and if matches static file, returns file
    - if matches a definition for a gateway service, makes connection to that service's port and passes request to service
    - Ensure that different web services use different port to communicate on
    - Simon is run on port 3000, startup service uses port 4000 (cannot repeat port, be consistent)
48. HTTP
    - Hypertext Transfer Protocol (HTTP) is how web talks
    - Protocol used for web browser to make request to web server (exchanged HTTP requests and responses)
    - see exchange by using browser debugger or console tool "curl"
    - General syntax for HTTP request:(<verb> <url path, parameters, anchor> <version>[<header key: value>]*[ <body>])
    - after version are optional headers defined by key value pairs
    - optional body, delimited from headers with two new lines
    - resource type is always a MIME type defined by IANA
    - General syntax for HTTP response :(<version> <status code> <status string>[<header key: value>]*[ <body>])
    - similar to request-->main difference is that first line represents version and status of response
    - VERBS
        - GET--> get requested resource (single or resource representing list of resources)
        - POST--> create new resource, body of request contains resource, response should include unique ID of newly created resource
        - PUT--> update a resource, either URL path, HTTP header, or body must contain unique ID of resource being updated, body of request should contain updated resource, body of response could contain resulting updated resource
        - DELETE--> delete resource, either URL path or HTTP header needs to have unique ID of resource to be deleted
        - OPTIONS-->get metadata about resource, only HTTP headers are returned (not the resource)
    - STATUS CODES
          - 1__-->Informational
              - 100-->Continue (service working on request)
          - 2__-->Success
              -200-->Sucess (requested resource found and returned)
              -201-->Created (request successful and new resource created)
              -204-->No content (successful but no resource returned)
          - 3__-->Redirect to some other location, or previously cached resource still valid
              -304-->Not Modified (cached version of resource still valid)
              -307-->Permanent redirect (resource no longer at request location, new location given in response location header)
              -308-->Temporary redirect (temp located different place, temp location givenin response location header)
          - 4__-->Client errors (request invalid)
              -400-->Bad request (request malformed or invalid)
              -401-->Unauthorized (valid authentication token not give)
              -403-->Forbidden (provided authentication token not authorized for resource)
              -404-->Not found (unknown resource requested)
              -408-->Request timeout (request takes too long)
              -409-->Conflict (provided resource represents an out of date version of resource)
              -429-->Too many requests (client making too many requests in too short amount of time)
          - 5__-->Server errors (request cannot be fulfilled b/c error on server)
              -500-->Internal Server Errror (server failed to properly process the request)
              -503-->Service unavailable (server temporarily down, client should try again with exponential back off)
    - HEADERS
          - specify metadata about request or response
          - Common headers
          - Authorization (ex. Bearer bskfjjaslkdjf)-->token that authorized user making request
          - Accept (ex. image/*)-->format the client accepts, may include wildcards
          - Content-Type (ex. text/html;charset=utf-8)-->format of content being sent
          - Cookie (ex. SessionID=sjdlf;)-->Key value pairs that are generated by the server and stored on client
          - Host (ex. info.cern.ch)-->domain name of server, required in all requests
          - Origin (ex. cs260.click)-->identifies the origin that caused request (host may only allow requests from specific origins)
          - Access-Control-Allow-Origin (ex. https://csd260.click)-->Server response of what origins can make request (could include wildcard)
          - Content-Length (ex. 368)-->number of bytes contained in response
          - Cache-Control (ex. public, max-age=604800)-->tells client how it can cache the response
          - User-Agent (ex. Mozilla/5.0 (Macintosh)-->client application making request
    - Body-->defined by Content-Type header (could be HTML text, binary image format, JSON, or JavaScript)-->client can specify accepted formates in accept header
    - Cookies
          - HTTP is stateless (does not know about previous or future requests)
          - Cookies allow state to be tracked (generated by server and passed to client as HTTP header)
          - Client then caches the cookie and returns it as HTTP header back to server on subsequent requests
          - Allows server to remember things about language, authentication
          - Allows servers to track and share what user does
49. Fetch
    - fetch API-->preferred way to make HTTP requests
    - "fetch" function is built into browser's JavaScript runtime
    - fetch takes URL and returns a promise
    - promise "then" function takes callback function (asynchronously called when requested URL content obtained)
    - if returned content is "application/json" type-->use json function on response object to convert to JavaScript
    - if request method unspecified, defaults to GET
    - example: fetch('https://quote.cs260.click')
                  .then((response) => response.json())
                  .then((jsonResponse) => {
                    console.log(jsonResponse);
                  });
      - POST request--> put in HTTP method and headers as option parameters
      - example: fetch('https://jsonplaceholder.typicode.com/posts', {
                      method: 'POST',
                      body: JSON.stringify({
                        title: 'test title',
                        body: 'test body',
                        userId: 1,
                      }),
                      headers: {
                        'Content-type': 'application/json; charset=UTF-8',
                      },
                    })
                      .then((response) => response.json())
                      .then((jsonResponse) => {
                        console.log(jsonResponse);
                      });
50. Node web service
    - With JavaScript-->write code that listens on network port, receives HTTP requests, processes them, responds
    - Create simple web service with this and then execute using Node.js
    - callback function takes request (req) and response (res)
    - called whenever server receives an HTTP request
    - real web service-->examine HTTP path and return meaningful content based on purpose of endpoint
    - server.listen-->given port and blocks until program is terminated
    - Nodemon package-->wrapper around node and watches for files in project directory to change, when something saved-->automatically restart node
51. Express
    - Node module that must be installed
    - supports routing requests for service endpoints, manipulating HTTP requests with JSON body content, generating HTTP responses, using middleware to add functionality
    - revolves on creating and using HTTP routing and middleware functions
    - express constructor to create express application and listen for HTTP requests on desired port
    - example: const express = require('express');
                const app = express();
                app.listen(8080);
    - with app object-->can add HTTP routing and middleware functions to application
    - Defining routes--> how HTTP endpoints are implemented in Express
    - routes call function based upon HTTP path
    - app object supports all HTTP verbs as functions on object (app.get())
    - example: app.get('/store/provo', (req, res, next) => {
                      res.send({name: 'provo'});
                    });
    - use next if routing function wants another function to generate response
    - path parameters by prefixing with :
    - example: app.get('/store/:storeName', (req, res, next) => {
                  res.send({name: req.params.storeName});
                });
    - reference parameters using req.params object
    - can have wildcard syntax or regex in path pattern
    - examples: // Wildcard - matches /store/x and /star/y
            app.put('/st*/:storeName', (req, res) => res.send({update: req.params.storeName}));
            // Pure regular expression
            app.delete(/\/store\/(.+)/, (req, res) => res.send({delete: req.params[0]}));
    - if next is not called, no following middleware functions will be invoked
    - Middleware and mediator (Express in our case)
    - Middleware represents componentized pieces of functionality
    - Mediator loads middleware components and determines order of execution
    - request to mediator, to middleware components
    - Express has middleware functions (default and install, can write own)
    - middleware function similar to routing function(which are middleware but only called if pattern matches)
    - middleware functions always called for every HTTP request unless preceding function does not call next
    - function middlewareName(req, res, next)
    - example of creating own: app.use((req, res, next) => {
                                      console.log(req.originalUrl);
                                      next();
                                    });
    - Middleware (app.use([path,]callback(req,res,next)))
    - order matters--> order that add middleware to app object controls order they are called, stops when no next called
    - built-in example: app.use(express.static('public'));
    - automatically calls next-->check others 
    - 3rd party--> include package in require function, often for functions to add feilds so other middleware can access functionality
    - handle error middleware: function errorMiddlewareName(err, req, res, next), can have it throw error
    - if called curl on error endpoint, see response
    - endpoints-->API calls you can make, functions you can call through URL
52. SOP and CORS
    - Cross-origin request (request from one domain and display from other) used to be allowed but hackers can take advantage
    - Use Same Origin Policy (SOP) now--> only allows JavaScripte to make requests to domain if domain user is viewing (security and complications)
    - Cross Origin Resource Sharing (CORS)--> allows client to specify origin of request and let server respond with what is allowed, if don't specify (assume same origin)
    - browser protects user-->only meant to alert user of nefarious intentions, hacker can still proxy request and ignore Access-Control-Allow-Origin header
53. Service Design
    - Web services provide interactive functionality
    - Need good design that will result in increased productivity, satisfied users, and lower processing costs
    - model teh application objects and interactions (from user POV)
    - Create sequence diagram-->defines necessary endpoints
    - Web services provided over HTTP (influences design)
    - leverage HTTP verbs or other file types so don't recreate functionality
    - cache servers--> increase performance
    - edge servers--> bring content closer
    - replication servers--> provide redundant copies of content/more resilient to network failures
    - Web service has multiple service endpoints (API or Application Programming Interface (could be one or many))
    - Each enpoint has single functional purposse
    - Grammatical-->resource (noun), act on it with verb
    - Readable-->clearly readable in URL path
    - Discoverable-->as expose resources that store other resources provide the endpoints for them (then only need to remember the top level and can access everything else)
    - Compatible-->Make it so can add new functionality w/o breaking existing, clients of service endpoints should ignore anything they don't understand
    - Simple--> keep endpoints focused on primary resources (avoid adding duplicate or parallel access), only one way to act on resource
    - Documented-->make uses of tools (like Open API Specification) to provide client libraries for endpoints and a sandbox for experimentation, make initial draft of your endpoint documentation
    - Remote Procedure Calls (RPC) exposes service endpoints as simple function calls
    - When used over HTTP, leverages POST HTTP verb, actual verb/subject of function call is represented by function name, name of function is entire path of URL or parameter in POST body
    - examples: POST /updateOrder HTTP/2
                {"id": 2197, "date": "20220505"}
                POST /rpc HTTP/2
                {"cmd":"updateOrder", "params":{"id": 2197, "date": "20220505"}}
    - Advantage of RPC is that it maps directly to function calls that exist within server (could be disadvantage because directly exposes the inner workings of service, creates coupling between endpoints and implementation)
    - Representational State Transfer (REST) takes advantage of principles of HTTP
    - REST HTTP verbs always act on resource
    - Operations on resource impact state of resources
    - allows for caching functionality of HTTP to work optimally
    - example: PUT /order/2197 HTTP/2
                {"date": "20220505"}
    - GraphQL--> focuses on manipulation of data
    - query that specifies desired data and how it should be joined and filtered
    - reduces number of calls-->sends single query requesting all infoin big JSON response
    - removes logic of parsing endpoints and mapping requests to specific resource
    - in GraphQL only one endpoint (query endpoint)
    - downside of flexibility is that client has power to consume resources on server
54. PM 2
    - To keep programs running after shutdown, register as daemon
    - PM 2 has web services continue running as a daemon and easy way to start/stop services
    - should not need to touch files but if services not running, commands
          - pm2 ls-->list all of the hosted node processes
          - pm2 monit--> visual monitor
          - pm2 start index.js -n simon --> add a new process with an explicit name 
          - pm2 start index.js -n startup --4000 -->add a new process with an explicit name and port parameter
          - pm2 stop simon --> stop a process
          - pm2 restart simon --> restart a process
          - pm2 delete simon --> delete a process from being hosted
          - pm2 delete all --> delete all processes
          - pm2 save --> save the current processes across reboot
          - pm2 restart all ---> reload all of the processes
          - pm2 restart simon --update-env --> reload process and update the node version to the current environment definition
          - pm2 update --> reload pm2
          - pm2 start env.js --watch-- ignore-watch="node_modules" -->automatically reload service when index.js changes
          - pm2 describe simon --> describe detailed process info
          - pm2 startup --> displays the command to run to keep PM2 running after a reboot
          - pm2 logs simon --> displays process logs
          - pm2 env 0 --> display environment variables for process (Use pm2 ls to get process ID)
55. Development and production environments
    - Separate development from release (could also be staging, internal testing, and external testing environemnts)
    - If seeking 3rd party security cerification (SOC2 compliance)-->environmentss must be strictly separate
    - Use automated integration process (contnuous integration (CI)) which will review code, lint, build, test, stage, test again, then deploy and let others know of release
    - For us-->use both but don't mix them-->deploy applicaation using CI (for us console shell script deploy.sh)
    - Advantage of using automated deployment process--> reproducible, encourages quick iterating (b/c easier to deploy)
    - ./deployService.sh -k ~/prod.pem -h yourdomain.click -s simon
          - '-k' --> provides credential file necessary to access production environement
          - '-h' --> domain name
          - '-s'--> name of application being deployed
    - When deploy file run-->
          - parse command parameters
          - copies source files into dist (distribution directory)
          - target directory deleted by executing commands remotely using ssh (secure shell program)
          - dist copied to production environment using secure copy program (scp)
          - Use shh-->installs node packages and restarts service daemon (PM2)
          - Clean up development environment by deleting distribution package    
56. Uploading Files
    - to upload files from frontend to backend use HTML input element of type file on frontend and multer NPM package on backend
    - frontend JavaScript handles uploading files, uses filename to set src attribute of image in DOM
    - Multer reads files from HTTP request, enforces size limit of upload, store file in uploads directory
    - Can also handle requests for static files (so serve up frontend code), handles error, provides get endpoint to serve up file from uploads directory
    - Where to store files
          - Not server--> not a lot of space, servers are transient, not backed up, if have multiple application server, can't assume that the one that has the data is going to be the one you request a download from
          - Use dedicated storage service that has durability guarantees (not tied to compute capacity), can be accessed by multiple application servers 
57. Storage services
    - Can store in database service -->but simpler solution that is cheaper
    - Don't store files on server-->limited space, server is temporary, need backup copies
    - AWS S3--> unlimited capacity, only pay for storage used, optimized for global access, keeps multiple redundant copies of every files, version the files, performant, supports metadata tags, can make files publicly available directly from S3, can keep files private and only accessible to your application
    - We will not use storage services

Adding Service to your React project-->need backend (index.js (Express stack) in directory called service), frontend (put in fetch statements that call services)
Debug services in development environment use viteconfig file that routes certain calls to a different port, need to run a node instance and tell it to listen on the port

58. Data Services
    - SQL databases usually were data service solution
    - NoSQL-->don't use general purpose but have certain types they specialize in (document, graph, JSON, time, sequence, key-value pair data)
    - Examples:
          - MySQL-->relational queries
          - Redis --> memory cached objects
          - ElasticSearch-->Ranked free text
          - MongoDB--> JSON objects (we use this one)
          - DynamoDB-->key value pairss
          - Neo4J-->Graph based data
          - InfluxDB--> Time series data
    - MongoDB
          - no strict schema requirement
          - schema can morph organically as data model evolves
          - To add field--> just insert field into documents
          - Query syntax is similar to JavaScript
      - install mongodb
      - use MongoClient object to make client connection to database (need username, passwork, hostname)
      - Example:
            const { MongoClient } = require('mongodb');
            const userName = 'holowaychuk';
            const password = 'express';
            const hostname = 'mongodb.com';
            const url = `mongodb+srv://${userName}:${password}@${hostname}`;
            const client = new MongoClient(url);
    - get collection object-->allows insert and query for documents
    - insert JavaScript object as Mongo document using "insertOne"
    - when insert document, if database or collection does not exist, Mongo automatically creates them
    - when document inserted, automatically assigned unique ID
    - Example:
        const collection = client.db('rental').collection('house');
        const house = {
          name: 'Beachfront views',
          summary: 'From your bedroom to the beach, no shoes required',
          property_type: 'Condo',
          beds: 1,
        };
        await collection.insertOne(house);
    - To query for document, use find function on collection object
    - find function is asynchronous and use await keyword
    - if don't include parameters in find, it will return all documents in collection (including ID)
    - specify options with order and limit results
    - infrastructure is often given to 3rd parties-->development focuses on application
    - Only load credentials when application executes
    - write JSON configuration file with credentials that is dynamically loaded into JavaScript to make database connection
    - use configuration file in development environement and deploy to production environment, don't commit it to Github (place in git.ignore)
59. Authorization services
    - authenticate user by asking for information, remember that user has authenticated by storing authentication token on user device
    - token is tored in cookie that is passed to web service with each request
    - store authorization (what they can access) for the user
    - give to authorization service-->has standard protocols (OAuth, SAML, OIDC)
          - can use Single Sign On (SSO) (allows user to use same credentials for multiple web applications) or Federated Login (allows user to log in once, authenticated token is reused automatically to log user in to multiple websites ex. Google)
60. Account creation and login
    - users need to uniquely identify themselves
          - two service endpoints
          - Create credential-->takes email,password and return cookie with authentication token and user ID--> returns 409 conflict statuds code if email already exists
          - authenticate or login-->takes email, password, returns cookie with authentication token and user ID-->if email does not exist or password is bad-->returns 401 unauthorized status code
          - once authenticated, control access to other endpoints
          - use getMe endpoint to get info from currently authenticated user (returns 401 if user does not exist)
    - Build web services using express
    - Handling requests (see code)
    - use uuid package (Universally Unique Identifier)--> to generate authentication token
    - use bcrypt to hash passwords
    - cookie-parser pagckage provides middleware for cookies, make secure
    - use httpOnly (tells browser not to allow JavaScript running on browser to read cookie)
    - use secure (requires HTTPS to be used when sending cookie back to server
    - sameSite--> only return the cookie to domain that generated it
    - bcrypt.compare-->compare provided password with hashed password in database
    - use curl '-c' and '-b' parameters tell curl to store and use cookies with the file
61. Simon Login
    - When user logs out, cookie is removed
    - service endpoints in index.js
    - New Express router (secureApiRouter) wraps existing router to add middleware function 
62. WebSocket
    - HTTP is client-server architecture (client requests, server responds)
    - does not work for asynchronous with communication, notifications, or peer-to-peer communication
    - created WebSocket-->fully duplexed (starts as client-server and then changes to peer-to-peer (send data at any time)
    - still only between 2 parties
    - if more people, server acts as intermediary (forwarding messages between poeple)
    - create WebSocket object by specifying port of communication
    - send messages with send function
    - register callback using onmessage function (receive messages)
    - example:const socket = new WebSocket('ws://localhost:9900');
                socket.onmessage = (event) => {
                  console.log('received: ', event.data);
                };
                socket.send('I am listening');
    - ws package creates WebSocketServer
          - when specify a port--> tell server to listen for HTTP connections and upgrade to WebSocket if request has (connection:Upgrade)
63. Debugging WebSocket
    - use VS Code to debug server
          - create directory
          - npm init -y
          - npm install ws
          - create main.js file with this code
                      const { WebSocketServer } = require('ws');
                const wss = new WebSocketServer({ port: 9900 });
                wss.on('connection', (ws) => {
                  ws.on('message', (data) => {
                    const msg = String.fromCharCode(...data);
                    console.log('received: %s', msg);
                    ws.send(`I heard you say "${msg}"`);
                  });
                  ws.send('Hello webSocket');
                });
          - set breakpoints on ws.send lines
          - start debugging with F5 (choose Node.js as debugger)
    - use Chrome to debug client
          - open using F12
          - executing code-->hit server breakpoint
              const socket = new WebSocket('ws://localhost:9900');
                socket.onmessage = (event) => {
                  console.log('received: ', event.data);
                };
          - select Network tab and HTTP messsage that was generated
          - click messages tab to see WebSocket messages
          - send socket.send('I am listening');
          - causes second server breakpoint
64. 
65. 
